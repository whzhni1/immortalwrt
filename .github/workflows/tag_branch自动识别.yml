#
# Copyright (c) 2019-2020 P3TERX <https://p3terx.com>
#
# This is free software, licensed under the MIT License.
# See /LICENSE for more information.
#
# https://github.com/P3TERX/Actions-ImmortalWrt
# Description: Build ImmortalWrt for Multiple Devices
#

name: tag_branch自动识别

on:
  repository_dispatch:
  workflow_dispatch:
    inputs:
      REPO_VERSION:
        description: '选择 ImmortalWrt 版本 (格式: v24.10.2 或分支名)'
        required: true
        default: 'v24.10.2'
        type: string
      DEVICE_MODEL:
        description: '选择路由器型号'
        required: true
        default: 'rax3000m'
        type: choice
        options:
          - rax3000m
          - ax6000
      LAN_IP:
        description: '设置LAN IP地址'
        required: true
        default: '192.168.1.1'
      UPLOAD_BIN_DIR:
        description: '上传bin目录'
        required: false
        default: false
        type: boolean
      UPLOAD_FIRMWARE:
        description: '上传固件到Artifacts'
        required: false
        default: true
        type: boolean
      UPLOAD_RELEASE:
        description: '发布固件到Release'
        required: false
        default: true
        type: boolean
  

env:
  REPO_URL: https://github.com/immortalwrt/immortalwrt
  FEEDS_CONF: feeds.conf.default
  DIY_P1_SH: part1.sh
  DIY_P2_SH: part2.sh
  TZ: Asia/Shanghai

jobs:
  build:
    runs-on: ubuntu-22.04
    
    permissions:
      contents: write
    
    steps:
    - name: 检查项目分支
      uses: actions/checkout@main

    - name: 设置版本变量
      run: |
        # 检查版本输入
        if [ -z "${{ github.event.inputs.REPO_VERSION }}" ]; then
          echo "❌ 错误：未指定版本信息"
          echo "请在工作流运行时指定 ImmortalWrt 版本（tag或branch）"
          exit 1
        fi
        
        REPO_VERSION="${{ github.event.inputs.REPO_VERSION }}"
        echo "REPO_VERSION=$REPO_VERSION" >> $GITHUB_ENV
        
        echo "======================================"
        echo "用户指定的版本: $REPO_VERSION"
        echo "源码仓库: $REPO_URL"
        echo "======================================"
        
    - name: 设置设备变量
      run: |
        # 检查设备型号输入
        DEVICE_MODEL="${{ github.event.inputs.DEVICE_MODEL }}"
        if [ -z "$DEVICE_MODEL" ]; then
          echo "❌ 错误：未指定设备型号"
          echo "请在工作流运行时选择设备型号"
          exit 1
        fi
        
        echo "DEVICE_MODEL=$DEVICE_MODEL" >> $GITHUB_ENV
        echo "CONFIG_FILE=${DEVICE_MODEL}.config" >> $GITHUB_ENV
        
        # 根据设备型号设置变量
        case "$DEVICE_MODEL" in
          "rax3000m")
            echo "DEVICE_NAME=cmcc_rax3000m" >> $GITHUB_ENV
            echo "DEVICE_FULL_NAME=CMCC-RAX3000M" >> $GITHUB_ENV
            echo "TARGET_NAME=mediatek-filogic" >> $GITHUB_ENV
            ;;
          "ax6000")
            echo "DEVICE_NAME=jdcloud_re-cp-03" >> $GITHUB_ENV
            echo "DEVICE_FULL_NAME=JDCloud-AX6000" >> $GITHUB_ENV
            echo "TARGET_NAME=mediatek-filogic" >> $GITHUB_ENV
            ;;
          *)
            echo "❌ 错误：不支持的设备型号: $DEVICE_MODEL"
            exit 1
            ;;
        esac
        
        echo "FILE_DATE=$(date +"%Y.%m.%d-%H%M")" >> $GITHUB_ENV
        
        echo "======================================"
        echo "设备型号: $DEVICE_MODEL"
        echo "配置文件: ${DEVICE_MODEL}.config"
        echo "======================================"

    - name: 初始化编译环境
      env:
        DEBIAN_FRONTEND: noninteractive
      run: |
        sudo rm -rf /etc/apt/sources.list.d/* /usr/share/dotnet /usr/local/lib/android /opt/ghc
        sudo -E apt-get -qq update
        sudo -E apt-get -qq install -y \
          ack antlr3 asciidoc autoconf automake autopoint binutils bison build-essential \
          bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext gcc-multilib g++-multilib \
          git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libglib2.0-dev libgmp3-dev libltdl-dev \
          libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libreadline-dev libssl-dev libtool lrzsz \
          mkisofs msmtp nano ninja-build p7zip p7zip-full patch pkgconf python2.7 python3 python3-pyelftools \
          libpython3-dev qemu-utils rsync scons squashfs-tools subversion swig texinfo uglifyjs upx-ucl unzip \
          vim wget xmlto xxd zlib1g-dev
        sudo -E apt-get -qq autoremove --purge
        sudo -E apt-get -qq clean
        sudo timedatectl set-timezone "$TZ"
        sudo mkdir -p /workdir
        sudo chown $USER:$GROUPS /workdir
        echo "======================================"
        echo "编译环境初始化完成"
        echo "======================================"

    - name: 清理磁盘空间
      uses: jlumbroso/free-disk-space@main
      with:
        tool-cache: true
        android: true
        dotnet: true
        haskell: true
        large-packages: true
        docker-images: true
        swap-storage: true

    - name: 下载源码
      working-directory: /workdir
      run: |
        df -hT $PWD
        echo "正在克隆 ImmortalWrt 源码..."
        echo "仓库: $REPO_URL"
        echo "版本: $REPO_VERSION"
        
        # 自动识别是 tag 还是 branch
        echo "======================================"
        echo "检测版本类型..."
        
        # 先尝试获取远程仓库的tags和branches列表
        echo "获取远程仓库信息..."
        
        # 检查是否为tag（通常以v开头，如v24.10.2）
        if git ls-remote --tags "$REPO_URL" | grep -q "refs/tags/$REPO_VERSION$"; then
          echo "✅ 检测到 Tag: $REPO_VERSION"
          echo "执行命令: git clone --depth 1 $REPO_URL -b $REPO_VERSION ImmortalWrt"
          
          if ! git clone --depth 1 "$REPO_URL" -b "$REPO_VERSION" ImmortalWrt; then
            echo "❌ 错误：无法克隆 tag '$REPO_VERSION'"
            echo "请检查 tag 是否存在"
            exit 1
          fi
          
          VERSION_TYPE="Tag"
          
        # 检查是否为branch
        elif git ls-remote --heads "$REPO_URL" | grep -q "refs/heads/$REPO_VERSION$"; then
          echo "✅ 检测到 Branch: $REPO_VERSION"
          echo "执行命令: git clone --depth 1 $REPO_URL -b $REPO_VERSION ImmortalWrt"
          
          if ! git clone --depth 1 "$REPO_URL" -b "$REPO_VERSION" ImmortalWrt; then
            echo "❌ 错误：无法克隆分支 '$REPO_VERSION'"
            echo "请检查分支是否存在"
            exit 1
          fi
          
          VERSION_TYPE="Branch"
          
        else
          echo "❌ 错误：'$REPO_VERSION' 既不是有效的 tag 也不是有效的 branch"
          echo ""
          echo "可用的 Tags（最近10个）："
          git ls-remote --tags "$REPO_URL" | tail -10 | awk '{print "  - " $2}' | sed 's|refs/tags/||'
          echo ""
          echo "可用的 Branches："
          git ls-remote --heads "$REPO_URL" | awk '{print "  - " $2}' | sed 's|refs/heads/||'
          exit 1
        fi
        
        ln -sf /workdir/ImmortalWrt $GITHUB_WORKSPACE/ImmortalWrt
        cd ImmortalWrt
        
        # 显示详细的版本信息
        echo "======================================"
        echo "ImmortalWrt 源码信息:"
        echo "版本类型: $VERSION_TYPE"
        echo "版本名称: $REPO_VERSION"
        echo "当前HEAD: $(git rev-parse --short HEAD)"
        echo "最新提交: $(git log --oneline -1)"
        
        # 尝试获取版本信息
        if [ -f "include/version.mk" ]; then
          VERSION_NUMBER=$(grep 'VERSION_NUMBER' include/version.mk | cut -d'=' -f2 | tr -d ' ' || echo "未找到")
          echo "版本号: $VERSION_NUMBER"
        fi
        
        if [ -f "Makefile" ]; then
          VERSION=$(grep '^VERSION' Makefile | head -1 | cut -d'=' -f2 | tr -d ' ' || echo "未找到")
          PATCHLEVEL=$(grep '^PATCHLEVEL' Makefile | head -1 | cut -d'=' -f2 | tr -d ' ' || echo "未找到")
          SUBLEVEL=$(grep '^SUBLEVEL' Makefile | head -1 | cut -d'=' -f2 | tr -d ' ' || echo "未找到")
          if [ "$VERSION" != "未找到" ]; then
            echo "ImmortalWrt 版本: $VERSION.$PATCHLEVEL.$SUBLEVEL"
          fi
        fi
        
        echo "克隆状态: ✅ 成功"
        echo "======================================"

    - name: 加载自定义feeds和执行脚本Part1
      run: |
        [ -e $FEEDS_CONF ] && mv $FEEDS_CONF ImmortalWrt/feeds.conf.default
        chmod +x $DIY_P1_SH
        cd ImmortalWrt
        echo "======================================"
        echo "执行自定义脚本 Part1..."
        echo "======================================"
        $GITHUB_WORKSPACE/$DIY_P1_SH

    - name: 更新并安装feeds
      run: |
        cd ImmortalWrt
        ./scripts/feeds update -i
        ./scripts/feeds install -a
        echo "Feeds 更新安装完成"

    - name: 加载设备配置和执行脚本Part2
      run: |
        # 检查设备配置文件
        if [ ! -f "${{ env.CONFIG_FILE }}" ]; then
          echo "❌ 错误：未找到配置文件 ${{ env.CONFIG_FILE }}"
          echo "请确保项目根目录存在该配置文件"
          ls -la *.config 2>/dev/null || echo "当前目录没有找到任何 .config 文件"
          exit 1
        fi
        
        # 复制配置文件
        echo "使用配置文件: ${{ env.CONFIG_FILE }}"
        cp ${{ env.CONFIG_FILE }} ImmortalWrt/.config
        
        # 执行 Part2 脚本
        chmod +x $DIY_P2_SH
        cd ImmortalWrt
        echo "======================================"
        echo "执行自定义脚本 Part2..."
        echo "======================================"
        $GITHUB_WORKSPACE/$DIY_P2_SH

    - name: 设置LAN IP地址
      run: |
        cd ImmortalWrt
        SET_IP="${{ github.event.inputs.LAN_IP }}"
        
        # 检查IP地址输入
        if [ -z "$SET_IP" ]; then
          echo "❌ 错误：未指定LAN IP地址"
          echo "请在工作流运行时设置LAN IP地址"
          exit 1
        fi
        
        # 验证IP地址格式
        if ! [[ $SET_IP =~ ^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$ ]]; then
            echo "❌ 错误：IP地址格式无效: $SET_IP"
            echo "请输入有效的IPv4地址，如: 192.168.1.1"
            exit 1
        fi
        
        # 修改默认IP地址
        sed -i "s/192\.168\.[0-9]*\.[0-9]*/$SET_IP/g" package/base-files/files/bin/config_generate
        
        # 修改LuCI相关IP
        if [ -d "feeds/luci/modules/luci-mod-system" ]; then
          find feeds/luci/modules/luci-mod-system -type f -name "flash.js" -exec sed -i "s/192\.168\.[0-9]*\.[0-9]*/$SET_IP/g" {} + 2>/dev/null || true
        fi
        
        echo "IP_ADDR=$SET_IP" >> $GITHUB_ENV
        echo "======================================"
        echo "LAN IP 地址设置为: $SET_IP"
        echo "======================================"

    - name: 下载软件包
      id: package
      run: |
        cd ImmortalWrt
        make defconfig
        make download -j8
        find dl -size -1024c -exec ls -l {} \;
        find dl -size -1024c -exec rm -f {} \;
        echo "======================================"
        echo "软件包下载完成"
        echo "======================================"

    - name: 编译固件
      id: compile
      run: |
        cd ImmortalWrt
        echo -e "$(nproc) 线程编译"
        make -j$(nproc) || make -j1 || make -j1 V=s
        echo "status=success" >> $GITHUB_OUTPUT
        echo "======================================"
        echo "固件编译完成"
        echo "======================================"

    - name: 检查磁盘使用情况
      if: (!cancelled())
      run: df -hT

    - name: 上传bin目录
      uses: actions/upload-artifact@main
      if: steps.compile.outputs.status == 'success' && github.event.inputs.UPLOAD_BIN_DIR == 'true'
      with:
        name: ImmortalWrt_bin_${{ env.DEVICE_NAME }}_${{ env.FILE_DATE }}
        path: ImmortalWrt/bin

    - name: 整理固件文件
      id: organize
      if: github.event.inputs.UPLOAD_FIRMWARE == 'true' && !cancelled()
      run: |
        cd ImmortalWrt/bin/targets/*/*
        rm -rf packages
        # 删除不需要的文件
        find . -type f -name "*.buildinfo" -o -name "*.manifest" -o -name "*kernel.bin" -o -name "*rootfs.tar.gz" -o -name "*.dtb" | xargs rm -f
        # 重命名固件文件
        for file in *; do
          if [[ -f "$file" ]]; then
            new_name="${{ env.FILE_DATE }}-${{ env.DEVICE_FULL_NAME }}-${file#*${{ env.DEVICE_NAME }}-}"
            mv "$file" "$new_name" 2>/dev/null || mv "$file" "${{ env.FILE_DATE }}-${{ env.DEVICE_FULL_NAME }}-$file"
          fi
        done
        echo "FIRMWARE=$PWD" >> $GITHUB_ENV
        echo "status=success" >> $GITHUB_OUTPUT
        echo "======================================"
        echo "固件整理完成，文件列表："
        ls -lh
        echo "======================================"

    
    - name: ABI对比分析
      if: steps.organize.outputs.status == 'success' && !cancelled()
      run: |
        echo "======================================"
        echo "🔍 ABI 对比分析 (内核版本对比)"
        echo "======================================"
        
        cd ImmortalWrt
        
        # 处理版本号（去除v前缀）
        OFFICIAL_VERSION="${{ github.event.inputs.REPO_VERSION }}"
        OFFICIAL_VERSION=${OFFICIAL_VERSION#v}  # 去除开头的v
        
        echo "📋 用户输入版本: ${{ github.event.inputs.REPO_VERSION }}"
        echo "📋 官方版本号: $OFFICIAL_VERSION"
        echo "🎯 目标平台: ${{ env.TARGET_NAME }}"
        echo "📱 设备型号: ${{ env.DEVICE_FULL_NAME }}"
        
        # 构建官方manifest文件URL
        OFFICIAL_MANIFEST_URL="https://downloads.immortalwrt.org/releases/$OFFICIAL_VERSION/targets/${{ env.TARGET_NAME }}/immortalwrt-$OFFICIAL_VERSION-${{ env.TARGET_NAME }}.manifest"
        
        echo "🔗 官方manifest地址: $OFFICIAL_MANIFEST_URL"
        
        # 下载官方manifest文件
        echo "📥 正在下载官方manifest文件..."
        if wget -q -O official.manifest "$OFFICIAL_MANIFEST_URL"; then
            echo "✅ 官方manifest下载成功"
            
            # 从官方manifest提取内核版本（格式：kernel - 6.6.104~3ca4b8cb2fcc3a2027e8496143a86cab-r1）
            OFFICIAL_KERNEL_LINE=$(grep '^kernel ' official.manifest | head -1)
            if [ -n "$OFFICIAL_KERNEL_LINE" ]; then
                OFFICIAL_KERNEL=$(echo "$OFFICIAL_KERNEL_LINE" | awk '{print $3}')
                echo "▪️  官方manifest内核行: $OFFICIAL_KERNEL_LINE"
                echo "▪️  提取的官方内核版本: $OFFICIAL_KERNEL"
            else
                echo "❌ 无法从官方manifest找到kernel行"
                OFFICIAL_KERNEL="unknown"
            fi
        else
            echo "❌ 官方manifest下载失败，可能该版本不存在或网络问题"
            OFFICIAL_KERNEL="unknown"
        fi
        
        # 查找本地编译的manifest文件
        echo ""
        echo "📁 查找本地manifest文件..."
        LOCAL_MANIFEST=$(find bin/targets -name "*.manifest" | head -1)
        
        if [ -n "$LOCAL_MANIFEST" ] && [ -f "$LOCAL_MANIFEST" ]; then
            echo "✅ 找到本地manifest: $LOCAL_MANIFEST"
            
            # 从本地manifest提取内核版本
            LOCAL_KERNEL_LINE=$(grep '^kernel ' "$LOCAL_MANIFEST" | head -1)
            if [ -n "$LOCAL_KERNEL_LINE" ]; then
                LOCAL_KERNEL=$(echo "$LOCAL_KERNEL_LINE" | awk '{print $3}')
                echo "▪️  本地manifest内核行: $LOCAL_KERNEL_LINE"
                echo "▪️  提取的本地内核版本: $LOCAL_KERNEL"
            else
                echo "❌ 无法从本地manifest找到kernel行"
                LOCAL_KERNEL="unknown"
            fi
        else
            echo "❌ 未找到本地manifest文件"
            LOCAL_KERNEL="unknown"
        fi
        
        echo ""
        echo "🔬 ABI兼容性分析结果:"
        echo "======================================"
        
        # 显示对比结果
        echo "📊 版本对比:"
        echo "   官方内核: $OFFICIAL_KERNEL"
        echo "   本地内核: $LOCAL_KERNEL"
        echo ""
        
        if [ "$OFFICIAL_KERNEL" != "unknown" ] && [ "$LOCAL_KERNEL" != "unknown" ]; then
            # 比较内核版本（精确比较）
            if [ "$OFFICIAL_KERNEL" = "$LOCAL_KERNEL" ]; then
                echo "✅ **ABI完全兼容**"
                echo "▪️  内核版本完全一致"
                echo "▪️  可以安全安装官方软件包"
                echo "▪️  软件包兼容性: 100%"
            else
                # 提取基础版本号（去掉git hash部分）
                OFFICIAL_BASE=$(echo "$OFFICIAL_KERNEL" | cut -d'~' -f1)
                LOCAL_BASE=$(echo "$LOCAL_KERNEL" | cut -d'~' -f1)
                
                echo "▪️  官方基础版本: $OFFICIAL_BASE"
                echo "▪️  本地基础版本: $LOCAL_BASE"
                echo ""
                
                if [ "$OFFICIAL_BASE" = "$LOCAL_BASE" ]; then
                    echo "⚠️ **ABI基本兼容**"
                    echo "▪️  内核基础版本一致，仅编译差异"
                    echo "▪️  大部分软件包兼容，内核模块可能需重新编译"
                    echo "▪️  软件包兼容性: 95%+"
                else
                    # 提取主版本号进行比较（例如6.6.104中的6.6）
                    OFFICIAL_MAJOR=$(echo "$OFFICIAL_BASE" | cut -d. -f1-2)
                    LOCAL_MAJOR=$(echo "$LOCAL_BASE" | cut -d. -f1-2)
                    
                    if [ "$OFFICIAL_MAJOR" = "$LOCAL_MAJOR" ]; then
                        echo "⚠️ **ABI部分兼容**"
                        echo "▪️  内核主版本一致，小版本不同"
                        echo "▪️  基础软件包兼容，内核相关包可能不兼容"
                        echo "▪️  软件包兼容性: 80%+"
                    else
                        echo "❌ **ABI不兼容**"
                        echo "▪️  内核主版本不同"
                        echo "▪️  不建议安装官方软件包"
                        echo "▪️  软件包兼容性: <50%"
                    fi
                fi
            fi
        else
            echo "⚠️ **无法完成ABI对比**"
            if [ "$OFFICIAL_KERNEL" = "unknown" ]; then
                echo "▪️  官方内核版本获取失败"
            fi
            if [ "$LOCAL_KERNEL" = "unknown" ]; then
                echo "▪️  本地内核版本获取失败"
            fi
            echo "▪️  建议手动验证软件包兼容性"
        fi
        
        echo "======================================"
        
        # 生成简明的ABI报告
        cat > abi_report.md <<EOF
        # ABI 兼容性报告
        
        ## 对比信息
        - **设备**: ${{ env.DEVICE_FULL_NAME }}
        - **目标平台**: ${{ env.TARGET_NAME }}
        - **官方版本**: $OFFICIAL_VERSION
        - **编译时间**: ${{ env.FILE_DATE }}
        
        ## 内核版本详情
        ### 官方manifest:
        \`\`\`
        $OFFICIAL_KERNEL_LINE
        \`\`\`
        **提取版本**: $OFFICIAL_KERNEL
        
        ### 本地manifest:
        \`\`\`
        $LOCAL_KERNEL_LINE
        \`\`\`
        **提取版本**: $LOCAL_KERNEL
        
        ## 对比结果
        $(if [ "$OFFICIAL_KERNEL" != "unknown" ] && [ "$LOCAL_KERNEL" != "unknown" ]; then
          if [ "$OFFICIAL_KERNEL" = "$LOCAL_KERNEL" ]; then
            echo "✅ **完全兼容** - 内核版本完全一致"
          else
            OFFICIAL_BASE=$(echo "$OFFICIAL_KERNEL" | cut -d'~' -f1)
            LOCAL_BASE=$(echo "$LOCAL_KERNEL" | cut -d'~' -f1)
            if [ "$OFFICIAL_BASE" = "$LOCAL_BASE" ]; then
              echo "⚠️ **基本兼容** - 基础版本一致，仅编译差异"
            elif [ "$(echo "$OFFICIAL_BASE" | cut -d. -f1-2)" = "$(echo "$LOCAL_BASE" | cut -d. -f1-2)" ]; then
              echo "⚠️ **部分兼容** - 主版本一致，小版本不同"
            else
              echo "❌ **不兼容** - 内核版本差异较大"
            fi
          fi
        else
          echo "⚠️ **无法确定** - 版本信息获取不完整"
        fi)
        
        ## 建议
        $(if [ "$OFFICIAL_KERNEL" != "unknown" ] && [ "$LOCAL_KERNEL" != "unknown" ]; then
          if [ "$OFFICIAL_KERNEL" = "$LOCAL_KERNEL" ]; then
            echo "- ✅ 可以安全安装所有官方软件包"
            echo "- ✅ 内核模块完全兼容"
          else
            OFFICIAL_BASE=$(echo "$OFFICIAL_KERNEL" | cut -d'~' -f1)
            LOCAL_BASE=$(echo "$LOCAL_KERNEL" | cut -d'~' -f1)
            if [ "$OFFICIAL_BASE" = "$LOCAL_BASE" ]; then
              echo "- ⚠️ 大部分软件包兼容"
              echo "- ⚠️ 内核模块可能需要重新编译"
              echo "- ✅ 用户空间软件包基本兼容"
            elif [ "$(echo "$OFFICIAL_BASE" | cut -d. -f1-2)" = "$(echo "$LOCAL_BASE" | cut -d. -f1-2)" ]; then
              echo "- ⚠️ 基础软件包兼容"
              echo "- ❌ 内核相关包可能不兼容"
              echo "- ⚠️ 建议测试关键功能"
            else
              echo "- ❌ 不建议安装官方软件包"
              echo "- ❌ 内核模块不兼容"
              echo "- ✅ 仅用户空间基础工具可能兼容"
            fi
          fi
        else
          echo "- ⚠️ 建议手动测试软件包兼容性"
          echo "- ⚠️ 谨慎安装内核相关软件包"
        fi)
        
        **生成时间**: $(date)
        EOF
        
        echo "✅ ABI分析报告已生成: abi_report.md"

    - name: 上传固件到Artifacts
      uses: actions/upload-artifact@main
      if: steps.organize.outputs.status == 'success' && github.event.inputs.UPLOAD_FIRMWARE == 'true'
      with:
        name: ${{ env.FILE_DATE }}-${{ env.DEVICE_FULL_NAME }}-Firmware
        path: ${{ env.FIRMWARE }}

    - name: 生成发布标签
      id: tag
      if: github.event.inputs.UPLOAD_RELEASE == 'true' && steps.organize.outputs.status == 'success' && !cancelled()
      run: |
        echo "release_tag=${{ env.FILE_DATE }}-${{ env.DEVICE_FULL_NAME }}" >> $GITHUB_OUTPUT
        echo "status=success" >> $GITHUB_OUTPUT
        
        # 生成发布说明
        cat > release.txt <<EOF
        # ${{ env.DEVICE_FULL_NAME }} 固件
        
        ## 📋 固件信息
        
        - **设备型号**: ${{ env.DEVICE_FULL_NAME }}
        - **目标平台**: ${{ env.TARGET_NAME }}
        - **编译时间**: ${{ env.FILE_DATE }}
        - **登录地址**: ${{ env.IP_ADDR }}
        - **默认密码**: 无密码或 password
        
        ## 📦 源码信息
        
        - **源码仓库**: ${{ env.REPO_URL }}
        - **源码版本**: ${{ env.REPO_VERSION }}
        
        ---
        EOF

    - name: 发布固件到Release
      uses: softprops/action-gh-release@v2.1.0
      if: steps.tag.outputs.status == 'success' && github.event.inputs.UPLOAD_RELEASE == 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        files: |
          ${{ env.FIRMWARE }}/*
          abi_analysis_report.md
        name: ${{ env.DEVICE_FULL_NAME }} - ${{ env.FILE_DATE }}
        tag_name: ${{ steps.tag.outputs.release_tag }}
        body_path: release.txt
        draft: false
        prerelease: false

    - name: 删除旧的workflow运行记录
      uses: Mattraks/delete-workflow-runs@v2
      with:
        retain_days: 7
        keep_minimum_runs: 10

    - name: 删除旧的Releases
      uses: dev-drprasad/delete-older-releases@v0.3.2
      if: github.event.inputs.UPLOAD_RELEASE == 'true' && !cancelled()
      with:
        keep_latest: 10
        delete_tags: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
